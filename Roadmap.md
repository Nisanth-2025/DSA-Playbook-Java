# Data Structures and Algorithms – Roadmap

---

## Phase 1: Arrays and Strings

### Arrays

1. Traversal Patterns  
   - Linear traversal  
   - Prefix arrays  
   - Suffix arrays  

2. Two Pointer Techniques  
   - Opposite direction pointers  
   - Same direction pointers  
   - Slow–fast pointer technique  

3. Sliding Window Techniques  
   - Fixed-size window  
   - Variable-size window  

4. Frequency and Hashing Techniques  
   - Counting occurrences  
   - Hash map and array combinations  

5. Sorting-Based Patterns  
   - Sort followed by logical processing  
   - Greedy techniques after sorting  

6. Kadane and Subarray Patterns  
   - Maximum subarray  
   - Minimum subarray  
   - Prefix sum with hash map  

---

### Strings

1. Frequency counting  
2. Two pointer techniques on strings  
3. Sliding window techniques on strings  
4. Palindrome-based patterns  
5. Basic string hashing  

---

## Phase 2: Recursion and Backtracking

### Recursion

1. Basic recursion  
   - Pick / Not Pick approach  

2. Multiple recursive calls  

3. Backtracking techniques  
   - Permutations  
   - Combinations  
   - Subsets  

---

## Phase 3: Linked Lists

### Linked List Patterns

1. Traversal and length calculation  
2. Two pointer techniques (fast–slow)  
3. Reversal patterns  
4. Dummy node techniques  
5. Cycle detection  

---

## Phase 4: Stack and Queue

### Stack Patterns

1. Next greater and next smaller element  
2. Monotonic stack  
3. Expression evaluation  
4. Stack-based simulation  

### Queue Patterns

1. Sliding window using deque  
2. Circular queue  
3. BFS-based queue simulation  

---

## Phase 5: Trees

### Tree Patterns

1. Tree traversals  
   - Preorder  
   - Inorder  
   - Postorder  
   - Level-order  

2. Height and depth calculations  
3. Diameter of a tree  
4. Path-based problems  
5. Lowest common ancestor (LCA)  
6. Binary search tree patterns  

---

## Phase 6: Heap and Priority Queue

### Heap Patterns

1. Top K elements  
2. Kth smallest and Kth largest elements  
3. Merging K sorted structures  
4. Heap with greedy techniques  

---

## Phase 7: Graphs

### Graph Patterns

1. Graph representation  
   - Adjacency list  
   - Adjacency matrix  

2. Graph traversals  
   - Breadth-first search (BFS)  
   - Depth-first search (DFS)  

3. Cycle detection  
4. Topological sorting  
5. Shortest path algorithms  
   - Dijkstra’s algorithm  
   - BFS-based shortest path  

6. Disjoint set (Union-Find)  

---

## Phase 8: Dynamic Programming

### Dynamic Programming Patterns

1. One-dimensional dynamic programming  
2. Two-dimensional dynamic programming  
3. Knapsack pattern  
4. Subsequence pattern  
5. Grid-based dynamic programming  
6. Dynamic programming on trees  
